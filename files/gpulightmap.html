<!--

This example dynamically generates an ambient occlusion lightmap on the GPU.
Ambient occlusion refers to the shadows due to a uniformly lit hemisphere
enclosing the model, which approximates the light arriving from the sky.
Let this example run for a while for a perfectly smooth lightmap.

Usually ambient occlusion is calculated for a given point in the scene by
tracing rays outward in random directions from that point and making the point
lighter if those rays don't intersect anything. This is inefficient because
each ray is independent and uncorrelated. It is much more efficient if all
sample rays in a pass are parallel because the intersections can then be
computed using rasterization. That is what this example does.

-->
<!DOCTYPE html>
<html><body>
  <script src="lightgl.js"></script>
  <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
  <script src="utils.js"></script>
  <script>

var angleX = 30;
var angleY = 30;
var gl = GL.create({
  // If we use hardware multisampling then there will be leaking around the
  // edges of quads due to extrapolation. For more details see the article at
  // http://www.opengl.org/pipeline/article/vol003_6/. These artifacts can be
  // avoided by using centroid sampling except it isn't supported by WebGL.
  antialias: true,
});
extend(gl);
if (!gl.getExtension('OES_texture_float')) {
  document.write('This demo requires the OES_texture_float extension to run');
  throw 'not supported';
}

var depthMap = new GL.Texture(1024, 1024, { format: gl.RED });
var depthShader = new asyncShader('depth');
var shadowTestShader = new asyncShader('shadow_test');

var texMech = new GL.Mesh({coords: true });

texMech.vertices.push([0.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 300.0, 0.0]);
texMech.vertices.push([0.0, 300.0, 0.0]);

texMech.coords.push([0.0, 0.0]);
texMech.coords.push([0.0, 1.0]);
texMech.coords.push([1.0, 1.0]);
texMech.coords.push([1.0, 0.0]);

texMech.triangles.push([0, 2, 1]);
texMech.triangles.push([0, 3, 2]);

texMech.compile();

var scene = new drawer();
var cube = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0.3, 0);
var cube1 = new asyncMesh('cube.obj').setScale(0.3).setPos(0.3, 0, 0);
var cube2 = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0, 0.3);
var plane = new asyncMesh('plane.obj').setScale(10);

scene.add(plane);
scene.add(cube);
scene.add(cube1);
scene.add(cube2);

var lightmapper = new lightAtlas(512, 2);
lightmapper.allocate(plane);
lightmapper.allocate(cube);
lightmapper.allocate(cube1);
lightmapper.allocate(cube2);


var exp_size = 4;
function renderLightmap(dir) {

  // Construct a camera looking from the light toward the object
  var r = scene.bounds.radius*exp_size, c = scene.bounds.center;
  gl.matrixMode(gl.PROJECTION);
  gl.pushMatrix();
  gl.loadIdentity();
  gl.ortho(-r, r, -r, r, -r, r);
  gl.matrixMode(gl.MODELVIEW);
  gl.pushMatrix();
  gl.loadIdentity();

  var at = c.subtract(dir);
  var useY = (dir.max() != dir.y);
  var up = new GL.Vector(!useY, useY, 0).cross(dir);
  gl.lookAt(c.x, c.y, c.z, at.x, at.y, at.z, up.x, up.y, up.z);

  // Render the object viewed from the light using a shader that returns the fragment depth
  var mesh = this.mesh;
  var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);
  depthMap.drawTo(function() {
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    scene.draw(depthShader, ['transform']);
  });

  // Reset the transform
  gl.matrixMode(gl.PROJECTION);
  gl.popMatrix();
  gl.matrixMode(gl.MODELVIEW);
  gl.popMatrix();

  // Run the shadow test for each texel in the lightmap and
  // accumulate that onto the existing lightmap contents
  depthMap.bind();
  lightmapper.texture.drawTo(function() {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    shadowTestShader.uniforms({
      shadowMapMatrix: shadowMapMatrix,
      sampleCount: 1000,
      light: dir,
      lightmapMult: lightmapper.delta,
    });
    scene.draw(shadowTestShader,['lightmapOff', 'transform']);
    gl.disable(gl.BLEND);
  });
  depthMap.unbind();
}

var textureMapShader = new asyncShader('tex_map');
var mouse = {
  x : 0,
  y : 0,
  object : null,
  free : true,
}
var cam = new camera();
cam.setZoom(4);

gl.onmousemove = function(e) {
  if (e.dragging) {
    mouse.free = false;
    
    if (mouse.object != 0) {
      var obj = scene.get(mouse.object);
      var mat = cam.getMatrix();
      var x = mat.transformVector(new GL.Vector(1, 0, 0));
      var y = mat.transformVector(new GL.Vector(0, -1, 0));
      var res = x.multiply(e.deltaX).add(y.multiply(e.deltaY)).multiply(0.01);
      obj.move(res.x, res.y, res.z);

    } else { 
      cam.updateAngles(e.deltaX, e.deltaY);
    }
  } else {
    mouse.free = true;
  }
  mouse.x = e.x;
  mouse.y = e.y;
};

gl.onupdate = function(seconds) {
  var speed = seconds * 4;

  // Forward movement
  var up = GL.keys.W | GL.keys.UP;
  var down = GL.keys.S | GL.keys.DOWN;
  var forward = GL.Vector.fromAngles((90 - cam.angleY) * Math.PI / 180, (180 - cam.angleX) * Math.PI / 180);
  cam.pos = cam.pos.add(forward.multiply(speed * (up - down)));

  // Sideways movement
  var left = GL.keys.A | GL.keys.LEFT;
  var right = GL.keys.D | GL.keys.RIGHT;
  var sideways = GL.Vector.fromAngles(-cam.angleY * Math.PI / 180, 0);
  cam.pos = cam.pos.add(sideways.multiply(speed * (right - left)));
};

gl.canvas.onmousewheel = function(e) {
  cam.updateZoom(e.wheelDelta / -240);
}

gl.canvas.onclick = function(e) {
  console.log(mouse.object);
}

var flip = false;
var r = 0.1;
var selectShader = asyncShader('select');
var uiShader = asyncShader('ui');

gl.ondraw = function() {
  
  gl.loadIdentity();
  cam.applyTransform();

  gl.clearColor(0, 0, 0, 0),
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  scene.draw(selectShader, ['id', 'transform']);
  pick();


  gl.clearColor(0.9, 0.9, 0.9, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  for(var i = 1; i < 10; i++) {
    // Alternate between a shadow from a random point on the sky hemisphere
    // and a random point near the light (creates a soft shadow)
    var dir = GL.Vector.randomDirection();
    flip = !flip;
    if (flip) dir = new GL.Vector(1, 1, 1).add(dir.multiply(r * Math.sqrt(Math.random()))).unit();
    //dir = new GL.Vector(1, 1, 1).unit();
    //quadMesh.drawShadow(dir.y < 0 ? dir.negative() : dir);
    renderLightmap(dir.y < 0 ? dir.negative() : dir);
  }

  // Draw the mesh with the ambient occlusion so far
  //quadMesh.lightmapTexture.bind();
  lightmapper.texture.bind();
  //textureMapShader.draw(mesh);

  //scene.draw(selectShader);
  textureMapShader.uniforms({'lightmapMult' : lightmapper.delta});
  scene.draw(textureMapShader, ['lightmapOff', 'transform']);

  textureMapShader.uniforms({lightmapMult : 1.0});
  depthMap.bind();
  gl.begin2D();
  uiShader.draw(texMech);
  gl.end2D();
};

gl.fullscreen();
gl.animate();
gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

  </script>
</body></html>
