<!--

This example dynamically generates an ambient occlusion lightmap on the GPU.
Ambient occlusion refers to the shadows due to a uniformly lit hemisphere
enclosing the model, which approximates the light arriving from the sky.
Let this example run for a while for a perfectly smooth lightmap.

Usually ambient occlusion is calculated for a given point in the scene by
tracing rays outward in random directions from that point and making the point
lighter if those rays don't intersect anything. This is inefficient because
each ray is independent and uncorrelated. It is much more efficient if all
sample rays in a pass are parallel because the intersections can then be
computed using rasterization. That is what this example does.

-->
<!DOCTYPE html>
<html><body>
  <script src="lightgl.js"></script>
  <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
  <script src="utils.js"></script>
  <script>

var angleX = 30;
var angleY = 30;
var gl = GL.create({
  // If we use hardware multisampling then there will be leaking around the
  // edges of quads due to extrapolation. For more details see the article at
  // http://www.opengl.org/pipeline/article/vol003_6/. These artifacts can be
  // avoided by using centroid sampling except it isn't supported by WebGL.
  antialias: true,
  alpha : false,
});
extend(gl);
if (!gl.getExtension('OES_texture_float')) {
  document.write('This demo requires the OES_texture_float extension to run');
  throw 'not supported';
}

var depthMap = new GL.Texture(1024, 1024, { format: gl.RED });
var depthShader = new asyncShader('depth');
var shadowTestShader = new asyncShader('shadow_test');

var texMech = new GL.Mesh({coords: true });

texMech.vertices.push([0.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 300.0, 0.0]);
texMech.vertices.push([0.0, 300.0, 0.0]);

texMech.coords.push([0.0, 0.0]);
texMech.coords.push([0.0, 1.0]);
texMech.coords.push([1.0, 1.0]);
texMech.coords.push([1.0, 0.0]);

texMech.triangles.push([0, 2, 1]);
texMech.triangles.push([0, 3, 2]);

texMech.compile();

var scene = new drawer();
var cube = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0.3, 0);
var cube1 = new asyncMesh('cube.obj').setScale(0.3).setPos(0.3, 0, 0);
var cube2 = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0, 0.3);
var plane = new asyncMesh('plane.obj').setScale(10);

scene.add(plane);
scene.add(cube);
scene.add(cube1);
scene.add(cube2);

var lightmapper = new lightAtlas(512, 2);
lightmapper.allocate(plane);
lightmapper.allocate(cube);
lightmapper.allocate(cube1);
lightmapper.allocate(cube2);


var exp_size = 4;
function renderLightmap(dir) {

  // Construct a camera looking from the light toward the object
  var r = scene.bounds.radius*exp_size, c = scene.bounds.center;
  gl.matrixMode(gl.PROJECTION);
  gl.pushMatrix();
  gl.loadIdentity();
  gl.ortho(-r, r, -r, r, -r, r);
  gl.matrixMode(gl.MODELVIEW);
  gl.pushMatrix();
  gl.loadIdentity();

  var at = c.subtract(dir);
  var useY = true;//(dir.max() != dir.y);
  var up = new GL.Vector(!useY, useY, 0).cross(dir);
  gl.lookAt(c.x, c.y, c.z, at.x, at.y, at.z, up.x, up.y, up.z);

  // Render the object viewed from the light using a shader that returns the fragment depth
  var mesh = this.mesh;
  var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);
  depthMap.drawTo(function() {
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    scene.draw(depthShader, ['transform']);
  });

  // Reset the transform
  gl.matrixMode(gl.PROJECTION);
  gl.popMatrix();
  gl.matrixMode(gl.MODELVIEW);
  gl.popMatrix();

  // Run the shadow test for each texel in the lightmap and
  // accumulate that onto the existing lightmap contents
  depthMap.bind();
  lightmapper.texture.drawTo(function() {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    shadowTestShader.uniforms({
      shadowMapMatrix: shadowMapMatrix,
      sampleCount: 1000,
      light: dir,
      lightmapMult: lightmapper.delta,
    });
    scene.draw(shadowTestShader,['lightmapOff', 'transform']);
    gl.disable(gl.BLEND);
  });
  depthMap.unbind();
}

function QuadMesh(numQuads, texelsPerSide) {
  this.size = Math.ceil(Math.sqrt(numQuads));
  this.texelsPerSide = texelsPerSide;
  this.mesh = new GL.Mesh({ normals: true, coords: true });
  this.index = 0;
  this.lightmapTexture = null;
  this.bounds = null;
  this.sampleCount = 0;

  // Also need values offset by 0.5 texels to avoid seams between lightmap cells
  this.mesh.addVertexBuffer('offsetCoords', 'offsetCoord');
  this.mesh.addVertexBuffer('offsetPositions', 'offsetPosition');
}

// Add a quad given its four vertices and allocate space for it in the lightmap
QuadMesh.prototype.addQuad = function(a, b, c, d) {
  var half = 0.5 / this.texelsPerSide;

  // Add vertices
  this.mesh.vertices.push(a.toArray());
  this.mesh.vertices.push(b.toArray());
  this.mesh.vertices.push(c.toArray());
  this.mesh.vertices.push(d.toArray());

  // Add normal
  var normal = b.subtract(a).cross(c.subtract(a)).unit().toArray();
  this.mesh.normals.push(normal);
  this.mesh.normals.push(normal);
  this.mesh.normals.push(normal);
  this.mesh.normals.push(normal);

  // Add fake positions
  function lerp(x, y) {
    return a.multiply((1-x)*(1-y)).add(b.multiply(x*(1-y)))
      .add(c.multiply((1-x)*y)).add(d.multiply(x*y)).toArray();
  }
  this.mesh.offsetPositions.push(lerp(-half, -half));
  this.mesh.offsetPositions.push(lerp(1 + half, -half));
  this.mesh.offsetPositions.push(lerp(-half, 1 + half));
  this.mesh.offsetPositions.push(lerp(1 + half, 1 + half));

  // Compute location of texture cell
  var i = this.index++;
  var s = i % this.size;
  var t = (i - s) / this.size;

  // Coordinates that are in the center of border texels (to avoid leaking)
  // var s0 = (s + half) / this.size;
  // var t0 = (t + half) / this.size;
  // var s1 = (s + 1 - half) / this.size;
  // var t1 = (t + 1 - half) / this.size;

  var s0 = (s + half*2.9) / this.size;
  var t0 = (t + half*2.9) / this.size;
  var s1 = (s + 1 - half*2.9) / this.size;
  var t1 = (t + 1 - half*2.9) / this.size;
  this.mesh.coords.push([s0, t0]);
  this.mesh.coords.push([s1, t0]);
  this.mesh.coords.push([s0, t1]);
  this.mesh.coords.push([s1, t1]);

  // Coordinates that are on the edge of border texels (to avoid cracks when rendering)
  var rs0 = s / this.size;
  var rt0 = t / this.size;
  var rs1 = (s + 1) / this.size;
  var rt1 = (t + 1) / this.size;
  this.mesh.offsetCoords.push([rs0, rt0]);
  this.mesh.offsetCoords.push([rs1, rt0]);
  this.mesh.offsetCoords.push([rs0, rt1]);
  this.mesh.offsetCoords.push([rs1, rt1]);

  // A quad is two triangles
  this.mesh.triangles.push([4 * i, 4 * i + 1, 4 * i + 3]);
  this.mesh.triangles.push([4 * i, 4 * i + 3, 4 * i + 2]);
};

QuadMesh.prototype.addDoubleQuad = function(a, b, c, d) {
  // Need a separate lightmap for each side of the quad
  this.addQuad(a, b, c, d);
  this.addQuad(a, c, b, d);
};

var c1 = new GL.Vector(-1, -1, -1);
var c2 = new GL.Vector(-1,  1, -1);
var c3 = new GL.Vector( 1,  1, -1);
var c4 = new GL.Vector( 1, -1, -1);
var c5 = new GL.Vector(-1, -1,  1);
var c6 = new GL.Vector(-1,  1,  1);
var c7 = new GL.Vector( 1,  1,  1);
var c8 = new GL.Vector( 1, -1,  1);

QuadMesh.prototype.addCube = function(off, size) {
  this.addQuad(c1.multiply(size).add(off), c2.multiply(size).add(off), c4.multiply(size).add(off), c3.multiply(size).add(off));
  this.addQuad(c8.multiply(size).add(off), c7.multiply(size).add(off), c5.multiply(size).add(off), c6.multiply(size).add(off));
  this.addQuad(c3.multiply(size).add(off), c7.multiply(size).add(off), c4.multiply(size).add(off), c8.multiply(size).add(off));
  this.addQuad(c2.multiply(size).add(off), c6.multiply(size).add(off), c3.multiply(size).add(off), c7.multiply(size).add(off));
  this.addQuad(c6.multiply(size).add(off), c2.multiply(size).add(off), c5.multiply(size).add(off), c1.multiply(size).add(off));
  this.addQuad(c1.multiply(size).add(off), c4.multiply(size).add(off), c5.multiply(size).add(off), c8.multiply(size).add(off));
}

QuadMesh.prototype.compile = function() {
  // Finalize mesh
  this.mesh.compile();
  this.bounds = this.mesh.getBoundingSphere();

  // Create textures
  var size = this.size * this.texelsPerSide;
  this.lightmapTexture = new GL.Texture(size, size, { format: gl.RED, type: gl.FLOAT });
};

QuadMesh.prototype.drawShadow = function(dir) {
  // Construct a camera looking from the light toward the object
  var r = this.bounds.radius, c = this.bounds.center;
  gl.matrixMode(gl.PROJECTION);
  gl.pushMatrix();
  gl.loadIdentity();
  gl.ortho(-r, r, -r, r, -r, r);
  gl.matrixMode(gl.MODELVIEW);
  gl.pushMatrix();
  gl.loadIdentity();
  var at = c.subtract(dir);
  var useY = (dir.max() != dir.y);
  var up = new GL.Vector(!useY, useY, 0).cross(dir);
  gl.lookAt(c.x, c.y, c.z, at.x, at.y, at.z, up.x, up.y, up.z);

  // Render the object viewed from the light using a shader that returns the fragment depth
  var mesh = this.mesh;
  var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);
  depthMap.drawTo(function() {
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    depthShader.draw(mesh);
  });

  // Reset the transform
  gl.matrixMode(gl.PROJECTION);
  gl.popMatrix();
  gl.matrixMode(gl.MODELVIEW);
  gl.popMatrix();

  // Run the shadow test for each texel in the lightmap and
  // accumulate that onto the existing lightmap contents
  var sampleCount = this.sampleCount+=1;
  depthMap.bind();
  this.lightmapTexture.drawTo(function() {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    shadowTestShader.uniforms({
      shadowMapMatrix: shadowMapMatrix,
      sampleCount: sampleCount,
      light: dir
    }).draw(mesh);
    gl.disable(gl.BLEND);
  });
  depthMap.unbind();
};

// Make a mesh of quads
var numArcQuads = 500;
var groundTilesPerSide = 5;
var texePerSide = 16;
var quadMesh = new QuadMesh(numArcQuads * 6 + groundTilesPerSide * groundTilesPerSide, texePerSide);
for (var i = 0; i < numArcQuads-6; i++) {
  var off = GL.Vector.randomDirection();
  if (off.y < 0) off.y *= -1;
  quadMesh.addCube(off, 0.1);
}


// Plane of quads
for (var x = 0; x < groundTilesPerSide; x++) {
  for (var z = 0; z < groundTilesPerSide; z++) {
    var dx = x - groundTilesPerSide / 2;
    var dz = z - groundTilesPerSide / 2;
    quadMesh.addQuad(
      new GL.Vector(dx, 0, dz),
      new GL.Vector(dx, 0, dz + 1),
      new GL.Vector(dx + 1, 0, dz),
      new GL.Vector(dx + 1, 0, dz + 1)
    );
  }
}
quadMesh.compile();

// The mesh will be drawn with texture mapping
var mesh = quadMesh.mesh;
var textureMapShader = new asyncShader('tex_map');

var mouse = {
  x : 0,
  y : 0,
  object : null,
}
var cam = new camera();
cam.setZoom(4);
gl.onmousemove = function(e) {
  if (e.dragging) {
    cam.updateAngles(e.deltaX, e.deltaY);
  }
  mouse.x = e.x;
  mouse.y = e.y;
};

gl.canvas.onmousewheel = function(e) {
  cam.updateZoom(e.wheelDelta / -240);
}

gl.canvas.onclick = function(e) {

}

var flip = false;
var r = 0.1;
var selectShader = asyncShader('select');

gl.ondraw = function() {
  
  gl.loadIdentity();
  cam.applyTransform();

  gl.clearColor(0, 0, 0, 0),
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  scene.draw(selectShader, ['id', 'transform']);


  gl.clearColor(0.9, 0.9, 0.9, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Alternate between a shadow from a random point on the sky hemisphere
  // and a random point near the light (creates a soft shadow)
  var dir = GL.Vector.randomDirection();
  flip = !flip;
  if (flip) dir = new GL.Vector(1, 1, 1).add(dir.multiply(r * Math.sqrt(Math.random()))).unit();
  //dir = new GL.Vector(1, 1, 1).unit();
  //quadMesh.drawShadow(dir.y < 0 ? dir.negative() : dir);
  renderLightmap(dir);
  

  // Draw the mesh with the ambient occlusion so far
  //quadMesh.lightmapTexture.bind();
  lightmapper.texture.bind();
  //textureMapShader.draw(mesh);

  //scene.draw(selectShader);
  textureMapShader.uniforms({lightmapMult : lightmapper.delta});
  scene.draw(textureMapShader, ['color', 'lightmapOff', 'transform']);

  textureMapShader.uniforms({lightmapMult : 1.0});
  //depthMap.bind();
  //gl.begin2D();
  //textureMapShader.draw(texMech);
  //gl.end2D();
};

gl.fullscreen();
gl.animate();
gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

  </script>
</body></html>
