<!--

This example dynamically generates an ambient occlusion lightmap on the GPU.
Ambient occlusion refers to the shadows due to a uniformly lit hemisphere
enclosing the model, which approximates the light arriving from the sky.
Let this example run for a while for a perfectly smooth lightmap.

Usually ambient occlusion is calculated for a given point in the scene by
tracing rays outward in random directions from that point and making the point
lighter if those rays don't intersect anything. This is inefficient because
each ray is independent and uncorrelated. It is much more efficient if all
sample rays in a pass are parallel because the intersections can then be
computed using rasterization. That is what this example does.

-->
<!DOCTYPE html>
<html><body>
  <script src="lightgl.js"></script>
  <script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
  <script src="utils.js"></script>
  <script>

var angleX = 30;
var angleY = 30;
var gl = GL.create({
  // If we use hardware multisampling then there will be leaking around the
  // edges of quads due to extrapolation. For more details see the article at
  // http://www.opengl.org/pipeline/article/vol003_6/. These artifacts can be
  // avoided by using centroid sampling except it isn't supported by WebGL.
  antialias: true,
});
extend(gl);
if (!gl.getExtension('OES_texture_float')) {
  document.write('This demo requires the OES_texture_float extension to run');
  throw 'not supported';
}

var depthMap = new GL.Texture(1024, 1024, { format: gl.RED });
var depthShader = new asyncShader('depth');
var shadowTestShader = new asyncShader('shadow_test');

var texMech = new GL.Mesh({coords: true });

texMech.vertices.push([0.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 0.0, 0.0]);
texMech.vertices.push([300.0, 300.0, 0.0]);
texMech.vertices.push([0.0, 300.0, 0.0]);

texMech.coords.push([0.0, 0.0]);
texMech.coords.push([0.0, 1.0]);
texMech.coords.push([1.0, 1.0]);
texMech.coords.push([1.0, 0.0]);

texMech.triangles.push([0, 2, 1]);
texMech.triangles.push([0, 3, 2]);

texMech.compile();

var scene = new drawer();
var cube = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0.3, 0);
var cube1 = new asyncMesh('cube.obj').setScale(0.3).setPos(0.3, 0, 0);
var cube2 = new asyncMesh('cube.obj').setScale(0.3).setPos(0, 0, 0.3);
var plane = new asyncMesh('plane.obj').setScale(10);
var plane1 = new asyncMesh('plane.obj').setPos(10, 0, 10);
var teapot = new asyncMesh('head.obj').setScale(0.03);

scene.add(plane);
scene.add(cube);
scene.add(cube1);
scene.add(cube2);
scene.add(plane1);
scene.add(teapot);

var lightmapper = new lightAtlas(1024, 3);
lightmapper.allocate(plane);
lightmapper.allocate(cube);
lightmapper.allocate(cube1);
lightmapper.allocate(cube2);
lightmapper.allocate(plane1);
lightmapper.allocate(teapot);


var exp_size = 4;
function renderLightmap(dir) {

  // Construct a camera looking from the light toward the object
  var r = scene.bounds.radius*exp_size, c = scene.bounds.center;
  gl.matrixMode(gl.PROJECTION);
  gl.pushMatrix();
  gl.loadIdentity();
  gl.ortho(-r, r, -r, r, -r, r);
  gl.matrixMode(gl.MODELVIEW);
  gl.pushMatrix();
  gl.loadIdentity();

  var at = c.subtract(dir);
  var useY = (dir.max() != dir.y);
  var up = new GL.Vector(!useY, useY, 0).cross(dir);
  gl.lookAt(c.x, c.y, c.z, at.x, at.y, at.z, up.x, up.y, up.z);

  // Render the object viewed from the light using a shader that returns the fragment depth
  var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);
  depthMap.drawTo(function() {
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    scene.draw(depthShader, ['transform']);
  });

  // Reset the transform
  gl.matrixMode(gl.PROJECTION);
  gl.popMatrix();
  gl.matrixMode(gl.MODELVIEW);
  gl.popMatrix();

  // Run the shadow test for each texel in the lightmap and
  // accumulate that onto the existing lightmap contents
  depthMap.bind();
  lightmapper.texture.drawTo(function() {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    shadowTestShader.uniforms({
      shadowMapMatrix: shadowMapMatrix,
      sampleCount: 1000,
      light: dir,
      lightmapMult: lightmapper.delta,
    });
    scene.draw(shadowTestShader,['lightmapOff', 'transform']);
    gl.disable(gl.BLEND);
  });
  depthMap.unbind();
}

var textureMapShader = new asyncShader('tex_map');
var mouse = {
  x : 0,
  y : 0,
  object : null,
  free : true,
}
var drag_coef = 0.83;
var drag_normal = new GL.Vector(0, 1, 0);
var cam = new camera();
cam.setZoom(4);

var result;
var originalOffset;

gl.onmousedown = function(e) {

  if (mouse.object != 0) {
    var obj = scene.get(mouse.object);
    var tracer = new GL.Raytracer();
    var ray = tracer.getRayForPixel(e.x, e.y);
    result = GL.Raytracer.hitTestMesh(tracer.eye, ray, obj);
    result.normal = tracer.getRayForPixel(gl.drawingBufferWidth/2, gl.drawingBufferHeight/2);//drag_normal;
    originalOffset = obj.pos.clone();
  }
}

gl.onmousemove = function(e) {
  if (e.dragging) {
    mouse.free = false;
    
    if (mouse.object != 0) {

      var obj = scene.get(mouse.object);
      var tracer = new GL.Raytracer();
      var ray = tracer.getRayForPixel(e.x, e.y);
      var t = result.hit.subtract(tracer.eye).dot(result.normal) / ray.dot(result.normal);
      var hit = tracer.eye.add(ray.multiply(t));
      var offset = originalOffset.add(hit.subtract(result.hit));
      obj.setPos(offset.x, offset.y, offset.z);

    } else { 
      cam.updateAngles(e.deltaX, e.deltaY);
    }
  } else {
    mouse.free = true;
  }
  mouse.x = e.x;
  mouse.y = e.y;
};

gl.onupdate = function(seconds) {
  var speed = seconds * 4;

  // Forward movement
  var up = GL.keys.W | GL.keys.UP;
  var down = GL.keys.S | GL.keys.DOWN;
  var forward = GL.Vector.fromAngles((90 - cam.angleY) * Math.PI / 180, (180 - cam.angleX) * Math.PI / 180);
  cam.pos = cam.pos.add(forward.multiply(speed * (up - down)));

  // Sideways movement
  var left = GL.keys.A | GL.keys.LEFT;
  var right = GL.keys.D | GL.keys.RIGHT;
  var sideways = GL.Vector.fromAngles(-cam.angleY * Math.PI / 180, 0);
  cam.pos = cam.pos.add(sideways.multiply(speed * (right - left)));
};

gl.canvas.onmousewheel = function(e) {
  cam.updateZoom(e.wheelDelta / -240);
}

gl.canvas.onclick = function(e) {
}

var flip = false;
var r = 0.1;
var selectShader = asyncShader('select');
var uiShader = asyncShader('ui');
var lambertShader = asyncShader('lambert');
var light = new GL.Vector(1, 1, 1);

gl.ondraw = function() {
  
  gl.loadIdentity();
  cam.applyTransform();

  gl.clearColor(0, 0, 0, 0),
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  scene.draw(selectShader, ['id', 'transform']);
  pick();


  gl.clearColor(0.9, 0.9, 0.9, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Alternate between a shadow from a random point on the sky hemisphere
  // and a random point near the light (creates a soft shadow)
  var dir = GL.Vector.randomDirection();
  flip = !flip;
  if (flip) dir = new GL.Vector(1, 1, 1).add(dir.multiply(r * Math.sqrt(Math.random()))).unit();
  renderLightmap(dir.y < 0 ? dir.negative() : dir);

  // Draw the mesh with the ambient occlusion so far
  lightmapper.texture.bind();

  textureMapShader.uniforms({'lightmapMult' : lightmapper.delta});
  scene.draw(textureMapShader, ['lightmapOff', 'transform']);
  // lambertShader.uniforms({light : light});
  // scene.draw(lambertShader, ['transform']);

  textureMapShader.uniforms({lightmapMult : 1.0});
  //depthMap.bind();
  gl.begin2D();
  uiShader.draw(texMech);
  gl.end2D();
};

gl.fullscreen();
gl.animate();
gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

  </script>
</body></html>
